---
layout: post
title: 关于 HTTP 的那些事
categories: [其他]
description: 发现，探索 HTTP 优质文章
keywords: HTTP
---

## `HTTP` 是什么
HTTP（Hypertext Transfer Protocol）是一种应用层协议，用于在计算机间传输超文本、网页及其他资源的数据。HTTP协议的基本思想是客户端发送请求，服务器端响应该请求并返回相应的资源。具体来说，HTTP协议包含以下几个方面的内容：

请求方法：客户端向服务器发送请求时，需要指定请求方法，目前HTTP/1.1规定了八种方法，包括GET、HEAD、POST、PUT、DELETE、OPTIONS、TRACE和CONNECT等。其中，GET用于请求指定的页面或资源，HEAD只返回首部信息而不返回实体的主体内容，POST用于向指定的资源提交数据等。

响应状态码：当服务器接收到客户端的请求后，会返回一个响应状态码，表示服务器对请求的处理结果。常见的状态码包括200、404、500等。

报文格式：HTTP协议的请求和响应报文都具有相同的格式。报文由报文头和报文体两部分组成，报文头包含了请求或响应的行、首部和协议版本等信息，报文体则包含了具体的请求或响应数据。

Cookie：Cookie是一种用于在客户端和服务器之间传递的数据，它可以记录用户的登录状态、浏览历史等信息。
总的来说，HTTP协议是建立在TCP/IP协议之上的一种用于传输超文本及其他数据的协议。它的请求-响应模式、状态码和报文格式等特点，使得HTTP协议成为了互联网上最为重要的协议之一。请求的一方叫客户端，响应的一方叫服务器端

所以`http` 服务器是继承 `tcp` 服务器，`http` 协议是应用层协议，是基于 `TCP` 的。 `TCP` 属于传输层协议。

浏览器本质上是一个 `HTTP` 协议中的请求方，使用 `HTTP` 协议获取网络上的各种资源，`HTML` 排版引擎用来展示页面，`javaScript` 引擎用来实现动态化效果，`HTTP` 是一种不保存状态的协议

HTTP与HTTPS的区别：

两种不同的通讯协议，它们的主要区别在于安全性、加密和验证机制不同,默认端口不一样

HTTPS在HTTP的基础上加入了 SSL/TLS 协议（Secure Sockets Layer/Transport Layer Security），使用了共享密钥加密和公钥加密，确保了数据在传输过程中的加密和安全性。

HTTPS在HTTP的基础上加入了 SSL/TLS 协议（Secure Sockets Layer/Transport Layer Security），使用了共享密钥加密和公钥加密，确保了数据在传输过程中的加密和安全性。

### http1.0 1.1 2.0 3.0 区别
HTTP（Hypertext Transfer Protocol）是一种用于 Web 通信的协议，目前主要有 HTTP 1.0、HTTP 1.1、HTTP 2.0、HTTP 3.0 四个版本


HTTP 1.0：单向请求/响应，每次请求都要建立一个新的连接，存在较大的开销。请求消息和响应消息中没有协议版本号字段。

HTTP 1.1：支持管道（Pipeline）方式请求/响应，多个请求可共用一个连接，大大减少了连接建立的数量。同时，引入了许多新特性，如持久连接、分块传输编码，等，以提升 HTTP 的性能和效率。请求和响应消息中均包含协议版本号标识字段。

HTTP 2.0：相比于 1.1 版本，HTTP 2.0 引入了新的二进制分帧机制，不再依赖于文本协议。同时，支持 Header 压缩、多路复用、服务器推送等特性，进一步提升了 HTTP 的性能和效率。单个TCP链接上使用多路复用，受TCP用塞控制的影响，少量的丢包，导致TCP链接上的流被阻塞

HTTP 3.0：目前还处于实验性阶段，为了解决HTTP 2 存在的对头阻塞问题，废弃了TCP 协议。引入了 QUIC 协议，基于 UDP 进行传输，可以提供更快的连接建立、更高的安全性以及更少的网络延迟等。减少了tcp三次握手时间，以及tls握手时间

解决了http 2.0中前一个stream丢包导致后一个stream被阻塞的问题
优化了重传策略，重传包和原包的编号不同，降低后续重传计算的消耗
连接迁移，不再用tcp四元组确定一个连接，而是用一个64位随机数来确定这个连接
更合适的流量控制

需要注意的是，虽然 HTTP 2.0 和 HTTP 3.0 在性能和效率方面有很大提升，但在实际应用中需要综合考虑其对于现有基础设施的依赖程度，以及它们在不同场景下的优势和劣势等因素，选择适合自己的协议版本。
## http 长什么样子

报文首部 + 空行 + 内容实体（报文主体）

报文首部 = 请求行+请求头（通用头，请求头，响应头，实体头

如果你不想用 `node` 去查看请求与响应的一些数据，也不想打开浏览器查看，这里有一个简单的方法，输入几行命令进行查看，其他参数，自行百度（我的是 `mac`)

`curl -I http://www.baidu.com` 就能看到服务器响应的首部信息的

`curl -v http:/www.baidu.com` 能够看到请求和响应的详细信息

- 请求参数 req

  > GET / HTTP/1.1
  > Host: localhost:8080
  > User-Agent: curl/7.54.0
  > Accept: \* > \*/

  '内容实体'

请求头信息
Accept： 浏览器告诉服务器所支持的数据类型
Host：访问服务器的哪台主机
Referer：告诉服务器的来源，在防盗链中使用的比较多
User-Agent： 浏览器类型，版本信息
Connention：连接方式
Cookie

响应头信息
Location：告诉浏览器你要去找谁
Server： 服务器的类型
Content-type：服务器返回的数据类型

### https数据传输的过程
复杂请求，浏览器会先发送OPTIONS请求进行预检（Preflight），以确定服务器是否支持该请求，然后服务器返回响应后，浏览器才会发送真正的请求。

简单请求就是，客户端向服务器发送HTTPS请求。

服务器将自己的证书发送给客户端。客户端浏览器收到证书后，先验证证书的合法性，包括颁发机构是否可信、证书是否过期、是否与当前服务器相匹配等。

客户端浏览器生成一个字符串，即“PreMaster Secret”，并用服务器的公钥加密该字符串，然后通过网络传递给服务器。这样，只有服务器能够解密该字符串，从而生成“Master Secret”。

服务器使用它的私钥解密客户端发来的“PreMaster Secret”，然后生成“Master Secret”。

服务器使用“Master Secret”生成会话密钥，用于加密和解密HTTPS报文（消息）的数据。

服务器将会话密钥通知客户端，客户端浏览器将会话密钥保存在内存中。

## HTTP 状态码
1xx（信息类状态码）：表示服务器正在处理客户端请求，但还需要客户端继续发送附加请求才能完成处理。

2xx（成功状态码）：表示服务器已成功接收、理解并接受请求。

3xx （重定向状态码）：表示客户端需要执行进一步的操作来完成请求。
  301：永久重定向状态码。当浏览器发现请求的URL已经被重定向到另一个URL时，会自动请求新的URL。服务器返回301状态码时，会告诉浏览器，请求的URL已经被永久性转移到了新的URL，浏览器应当对所有访问原始URL的请求进行修改，改为访问新的URL。

  302：临时性重定向状态码。当浏览器发现请求的URL已经被重定向到另一个URL时，会自动请求新的URL。服务器返回302状态码时，会告诉浏览器，请求的URL已经被临时性的转移到新的URL，浏览器应当只对本次访问请求的URL使用新的URL。

  304：未修改状态码。当浏览器发送一个请求，服务器进行修改判断后发现请求的页面并没有发生变化时，会返回304状态码，告诉浏览器可以直接从本地缓存中获取

  307状态码表示临时重定向，与302有些类似，表示请求的资源已被暂时地移动到另一个URL上。与302不同的是客户端收到307响应时，会保留原始请求的请求方法和主体，重新发出一条请求，这个新请求会指向新的URL。这对于需要在新URL上保持相同请求方法和主体的POST请求非常有用。

总的来说，302和307的主要区别在于客户端如何处理重定向和搜索引擎如何处理被重定向的资源。

4xx（客户端错误状态码）：表示客户端的请求有误，包括语法错误、无权访问、不存在的资源等。

5xx（服务器错误状态码）：表示服务器执行请求时发生了错误。

## 输入 URL 到页面展示，这中间发生了什么
DNS解析：浏览器会先根据URL中的域名，向DNS服务器请求获取该域名的IP地址。如果在本地DNS缓存中找到了该域名的对应IP地址，则直接返回给浏览器；否则，向互联网上的DNS服务器请求解析该域名对应的IP地址。

TCP连接：浏览器使用HTTP协议与Web服务器建立TCP连接，并发送HTTP请求报文。

服务器处理请求并响应：Web服务器接收到请求后，进行处理，并返回HTTP响应报文。

浏览器处理响应并渲染页面：浏览器接收到来自服务器的响应后，如果是一个html文件，则开始解析html文件，构建DOM树、CSS样式等，进行页面渲染。在页面渲染完成后，可能还会执行一些JavaScript代码，进行一些页面的交互操作。

TCP关闭：浏览器接收完服务器的响应后，会关闭TCP连接，完成一次HTTP请求。
以上是请求一个HTML页面的大致流程，如果请求的页面中涉及到其他的资源（如图片、CSS、JavaScript文件等），则还需要进行多次HTTP请求，整个流程类似，只是在响应数据的处理和页面渲染等方面稍有不同。
### 域名解析过程是怎样的？
浏览器首先查询本地DNS缓存，看是否已经缓存了该域名的解析结果。如果有，则直接返回IP地址；如果没有，则继续进行下一步。

浏览器向本地域名服务器发送域名查询请求。如果本地域名服务器已经缓存了该域名解析结果，则直接返回IP地址；否则，它将依次向根域名服务器、顶级域名服务器、权威域名服务器查询，直到找到该域名的IP地址。

根域名服务器通常会返回下一级域名服务器的IP地址，浏览器会向下一级域名服务器继续发送查询请求，直到找到该域名对应的IP地址。

本地域名服务器将IP地址返回给浏览器，浏览器将IP地址保存到本地DNS缓存中，并向该IP地址发起Web请求。
以上过程中，本地DNS缓存的存在可以减少DNS查询的时间，提高网页访问速度。通常，DNS查询需要几十毫秒至数秒钟不等的时间，因此浏览器需要等待域名解析完成后才能发起真正的请求。

## TCP和UDP最大的区别是什么?
TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）是互联网上最常用的两个传输协议，它们的最大区别在于：

连接与无连接：TCP是一种面向连接的协议，它需要在进行数据传输之前先建立连接，而UDP是一种无连接的协议，不需要建立连接就可以直接传输数据，但也因此UDP对数据的丢失和乱序处理能力比TCP差。

可靠与不可靠：TCP可以保证所传输数据的可靠性，即发送方发送的数据会被对方接收到，并且保证数据的顺序，而UDP则不保证数据传输的可靠性和顺序，因为它不会对数据包丢失或乱序做出任何处理。

速度：由于TCP需要在发送和接收数据之前进行三次握手和四次挥手等一系列的操作以保证数据的可靠传输和顺序，所以相较UDP，TCP的传输速度会较慢。

应用场景：TCP适用于需要数据传输的完整性和准确性较高的场景，例如文件下载、电子邮件，而UDP适用于实时性较强的应用场景，例如语音通话、视频会议等。
总的来说，TCP适用于对数据传输安全性和完整性要求较高的场景，而UDP则适用于实时性要求较高的场景，但是也存在丢包和乱序等问题。因此，在实际的应用场景中，需要根据具体的需求来选择适合的传输协议。

Chrome 有个机制，同一个域名同时最多只能建立 6 个TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。如果当前请求数量少于6个，会直接建立TCP连接。
### TCP 建立连接过程握手需要三次？
TCP建立连接的过程是通过三次握手来完成的，即发送方向接收方发送了三个包，确保双方都可以进行数据通信。三次握手的过程如下：

第一次握手：客户端发送一个带有SYN（同步）标志的数据包给服务器，并进入SYN_SENT状态，等待服务器的确认。

第二次握手：服务器收到客户端的SYN包后，会返回一个带有SYN/ACK（同步和确认）标志的数据包，表示同意客户端的请求，并准备好了向客户端发送数据。同时服务器端也会进入SYN_RCVD状态。

第三次握手：客户端收到服务器的SYN/ACK包后，也会向服务器发送一个带有ACK（确认）标志的数据包，表示已经收到服务器的确认，并准备好可以通信了。服务器端在接收到客户端的ACK包之后，也会进入ESTABLISHED状态，表示双方可以进行数据通信了。

为什么需要三次握手呢？因为TCP是一种面向连接的协议，要保证数据能够准确地从发送方传输到接收方，需要进行可靠性控制。在TCP的三次握手过程中，第一次握手是为了建立连接，第二次握手是为了确认连接，并准备发送数据，第三次握手是为了最终确认连接，并保证双方都可以进行数据通信。通过三次握手，可以确保TCP连接的可靠性和稳定性。
另外，三次握手是TCP的最小要求，并不能保证数据传输的绝对可靠性。在实际应用中，还需要采用其他的措施，如数据校验、确认、超时重传等，来确保相关数据的可靠性和完整性。

### 四次挥手
四次挥手指的是TCP连接的关闭过程。它的具体过程如下：

第一次：发送方向接收方发送FIN包，表示发送方已经没有数据需要发送了。

接收方向发送ACK确认包，表示已经收到发送方发送的FIN包。此时，接收方已经不能向发送方再发送数据，但是发送方还可以向接收方发送数据。

第二次：如果接收方还有需要向发送方发送的数据，则继续发送数据，直到数据发送完毕。

第三次：接收方向发送方发送FIN包，表示接收方已经没有数据需要发送了。

第四次：发送方向接收方发送ACK确认包，表示已经收到接收方发送的FIN包，并同样向接收方发送FIN包。

接收方向发送方发送ACK确认包，表示已经收到发送方发送的FIN包。
整个过程需要进行4次通信，因此被称为四次挥手。这个过程就像是双方握手的过程，只不过是在结束连接时进行的挥手。一个TCP连接的建立需要三次握手，而连接的结束则需要四次挥手。

## 浏览器三级缓存机制
HTTP缓存：HTTP缓存也称浏览器缓存，是浏览器本地存储缓存的数据，在缓存有效期内，浏览器可以直接从本地读取缓存的数据，而无需重新请求服务器。HTTP缓存可以有效提高网站的加载速度，减少对服务器的请求次数。 也叫磁盘缓存分为强缓存和协商缓存=>浏览器做静态资源缓存

系统缓存：系统缓存指的是操作系统级别的缓存，包括了DNS缓存、ARP缓存、Socket缓存等。其中，DNS缓存用于缓存域名解析结果，ARP缓存用于缓存网络MAC地址与IP地址的映射关系，Socket缓存用于维护TCP连接状态等。系统缓存可以降低网络延迟，提高网站的性能和稳定性。

内存缓存(关闭页面失效）Memory Cache：Memory Cache是浏览器内存缓存，它是直接保存在内存中的缓存，如果关闭浏览器，则Memory Cache中的数据将被清空。与HTTP缓存不同，Memory Cache的有效期非常短暂，仅在当前会话中有效。
以上三种缓存方式在浏览器中都扮演着非常重要的角色，能够有效提高Web应用的性能和用户体验，减轻服务器的负担，降低网站运营的成本。

### 浏览器缓存的方式有哪些（HTTP缓存
Service Worker缓存：Service Worker可以作为浏览器和网络之间的代理，拦截和处理请求。通过使用Service Worker缓存，浏览器可以在离线情况下访问缓存中的内容。

Web Storage：Web Storage是浏览器提供的本地存储机制，包括localStorage和sessionStorage。它们可以存储在浏览器端的键值对，具有较高的读取速度和容量限制。
这些缓存方式可以使浏览器更快地加载网页资源，减少服务器负载，提高网页性能和用户体验。


强缓存（也称为本地缓存）是指在浏览器首次请求资源时，服务器返回的响应头中包含了缓存策略，浏览器会根据缓存策略在客户端中缓存资源。当再次请求该资源时，浏览器会检查缓存策略和请求头，如果缓存策略和请求头匹配，则浏览器直接从缓存中加载资源，而不必再向服务器发送请求，从而大幅度缩短了资源加载时间。
常见的强缓存策略有两种：expires 和 Cache-Control。

expires：服务器返回响应头，指定资源过期时间，在过期时间前浏览器直接使用本地缓存。expires 采用的是绝对时间，由于本地时间可能和服务器时间不一致，可能导致缓存过期时间不准确。

Cache-Control：在 HTTP/1.1 中新增的缓存控制方式，采用相对时间，可解决 expires 的不足。常见的 Cache-Control 包括 max-age、no-cache、no-store、public、private 等等。
使用强缓存可以减少服务器响应时间和网络带宽消耗，相应地提高了网站性能和用户体验。但在某些情况下，可能需要及时获取最新内容，此时需要使用弱缓存（如 Last-Modified）结合协商缓存来实现。


协商缓存是指浏览器重复利用已下载的资源的过程中，通过向服务器发送一个请求，向服务器询问该资源是否发生了变化（即是否过期），从而决定是否需要重新下载该资源。如果资源未发生变化，则服务器可以只返回一个小的响应头来提示客户端使用本地缓存的资源。
协商缓存可以通过两种机制来实现：If-Modified-Since 和 If-None-Match。

If-Modified-Since：当浏览器请求资源时，服务器会将资源的最后修改时间放入响应头中（通过 Last-Modified 属性），当浏览器再次请求资源时，会将该时间通过 If-Modified-Since 的方式发送给服务器，服务器会比较这个时间和自己记录的该资源的最后修改时间，如果两者相同则返回 304 Not Modified 状态码，告诉浏览器继续使用本地缓存。

If-None-Match：在响应头中添加 ETag 属性，每当资源发生变化时，服务器将这个 ETag 的值更改，浏览器再次请求时，将该值通过 If-None-Match 的方式发送给服务器，服务器会将其与当前资源的 ETag 值进行比较，如果相同则返回 304 Not Modified 状态码。
使用协商缓存可以减少网站带宽消耗和服务器处理时间，从而提高网站性能和用户体验。与强缓存结合使用，可以最大程度地利用本地缓存，减少不必要的网络请求。

第一次访问服务器的时候，服务器返回资源和缓存规则，客户端会把此资源缓存在本地的缓存数据库中

第二次客户端需要此数据的时候，要取得缓存的标识，然后去问一下服务的资源是否是最新的

如果是最新的，返回一个状态码，则直接使用缓存数据，如果不是，则返回新的数据和缓存规则，客户端根据新的规则缓存数据
![](../../images/http/1.png)
![](../../images/http/6.png)

![](../../images/http/3.png)
![](../../images/http/5.png)


```
// 第一次访问服务器的时候，服务器返回资源和缓存规则，客户端会把此资源缓存在本地的缓存数据库中
// 第二次客户端需要此数据的时候，要取得缓存的标识，然后去问一下服务的资源是否是最新的
// 如果是最新的，则直接使用缓存数据，如果不是，则返回新的数据和缓存规则，客户端根据新的规则缓存数据

const http = require("http")
const url = require("url")
const path = require("path")
const fs = require('fs')
const mime = require('mime') // 设置返回文件的类型
const crypto = require('crypto');



http.createServer((req, res) => {
  let {
    pathname
  } = url.parse(req.url, true)

  // /Users/sunseekers/Desktop/code/node/http/cache/index.html
  let filepath = path.join(__dirname, pathname)
  fs.stat(filepath, (err, stat) => {
    if (err) {
      // console.log(err);
      return sendError(req, res)
    } else {
      // let ifModified = req.headers['if-modified-since']
      // let LastModified = stat.ctime.toGMTString()
      // if (ifModified == LastModified) {
      //   res.writeHead(304) // 服务器返回304，表示资源未改过，可以直接用原来的
      //   res.end('')
      // } else {
      //   return sendLastModified(req, res, filepath, stat)
      // }

      // 第一种（ETag)，生成一段hash值

      let ifNoneMatch = req.headers['if-none-match']
      let out = fs.createReadStream(filepath)
      let md5 = crypto.createHash('md5')
      out.on('data', data => {
        md5.update(data)
      })
      out.on('end', data => {
        //1.相同的输入相同的输出 2 不同的输入不同的输入 3 不能从输出反推出输入

        let etag = md5.digest('hex')
        return sendETag(req, res, filepath, etag);

        // if (ifNoneMatch == etag) {
        //   res.writeHead(304);
        //   res.end('');
        // } else {
        //   return sendETag(req, res, filepath, etag);
        // }
      })
    }
  })
}).listen(8888, () => {
  console.log('server starts at http://localhost:8888/');
})

// 通过响应头发给客户端，客户端会把此时间保存起来，下次在获取资源的时候会把这个时间在发给服务器

// 第一种（Last-Modified）设置缓存的规则：根据文件最后的修改时间来定；缺点，修改时间变了，但是内容没有变/服务器时间精确问题/东西存储在cdn服务器上
function sendLastModified(req, res, filepath, stat) {
  res.setHeader('Last-Modified', stat.ctime.toGMTString())
  res.setHeader("Content-Type", mime.getType(filepath))
  fs.createReadStream(filepath).pipe(res)
}

function sendError(req, res) {
  res.end("Not found")
}

// 第一种（ETag)，生成一段hash值
function sendETag(req, res, filepath, etag) {
  res.setHeader('ETag', etag)

  // 强制缓存
  res.setHeader('Cache-Control', 'max-age=30');

  res.setHeader("Content-Type", mime.getType(filepath))
  fs.createReadStream(filepath).pipe(res)
}

/**
 * 强制缓存
 * 把资源缓存在客户端，如果客户端再次需要此资源的时候，先获取到缓存中的数据，看是否过期，如果过期了。再请求服务器
 * 如果没过期，则根本不需要向服务器确认，直接使用本地缓存即可
    res.setHeader('Cache-Control', 'max-age=30');
 *
 */
```

![](../../images/http/cache.png)

### CDN缓存机制原理
是一种分布式部署的服务器集群，利用缓存将内容保存在离用户最近的节点上，以提升用户访问速度和体验

当用户访问一个 CDN 上的资源时，会先检查本地缓存有没有该资源，如果有则直接使用本地缓存，否则会向 CDN 服务器发起请求。

CDN 服务器会先检查自己是否有缓存该资源，如果有，则直接返回缓存数据；如果没有则向源站请求数据，并在下次请求中添加缓存头部信息，以便下次能够快速获取缓存数据。

如果源站返回的数据发生变更，则 CDN 服务器的缓存也会失效，当 CDN 缓存过期或者源站内容更新时，CDN 会向源站发起请求，更新缓存内容。同时，CDN 也会在 HTTP 头部添加 Cache-Control 和 ETag 等字段，以指示客户端如何缓存数据。

## 流

当我们往可写流写数据的时候，不是会立刻写入文件的，而是会先写入缓存区，然后等缓存区写满了之后再次真正的写入文件里

加密就是一种流的转化

普通流里面放的是普通流，对象流里面放的是对象流

数据在不同的层传递，名字不一样
物理层：帧 `frame`
网络层：数据包 `package`
传输层：段 `segment`

`ip` 头服务类型普通< 音频 < 视频 < 网络 < 路由。在数据传输的时候有这个优先级
数据在传输的过程中切割了多少片，偏移量是多少，都在 `ip` 数据包的请求头里面

大文件分段传输的时候，这里用的上核心问题还是带宽不够

分段传输数据

```
const http = require('http')
http
  .createServer((req, res) => {
    if (req.url === '/') {
      res.setHeader('Content-Type', 'text/html;charset=utf8')
      res.setHeader('Content-Length', 10)
      res.setHeader('Transfer-Encoding', 'chunked')
      res.write('<p>我来了</p>')
      setTimeout(() => {
        res.write('第一次传输数据<br/>')
      }, 1000)
      setTimeout(() => {
        res.write('第二次传输数据<br/>')
      }, 2000)
      setTimeout(() => {
        res.write('第三次传输数据<br/>')
        res.end() //如果这里不设置结束的话，会一直在等待服务器传输数据过来，数据传输完了，我们要手动结束这个响应
      }, 3000)
    }
  })
  .listen(8888, () => {
    console.log('Local:   http://localhost:8888/ ')
  })
```

## 专有名词解释

`CDN` : CDN（内容分发网络）是一种通过在全球多个地理位置分布的服务器上缓存静态资源，以加速网站内容传输的技术。CDN可以自动选择最近的服务器，从而减少网络延迟和带宽消耗。此外，CDN还可以提供一些高级功能，例如自动压缩、图片优化等等。因此，CDN相对于域名分离来说，可以更有效地提高网站的性能和可靠性。

`TCP` :传输层

`IP` : 网际层，主要目的是解决寻址和路由的问题，以及两点间传送数据包

`IP` 地址： 定位互联网上的每一台计算机，比如电话系统里面，电话号码就相当于 `IP` 地址

`TCP` 协议：基于 `IP` 协议提供可靠的，字节流形式的通信，是 `HTTP` 协议得以实现的基础

`DNS` 域名系统：用有意义的名字作为 `IP` 地址的等价替换，把域名做一个转化，映射到他的真实 `IP` 叫做域名解析。比如给电话号码起一个备注，根据备注找到电话号码就叫域名解析

`URR/URL` 统一的资源标识符/统一定位符；通过前面的可以找到互联网上的主机，但是主机上面有很多东西，需要进一步定位到具体的，就用到了他。比如电话打通了，开始说具体事情了。

`SSL/TLS` :（对称加密，非对称加密....) 他是一个负责加密通信的安全协议，(比如：保证通话内容没有被窃听）在 `TCP/IP` 协议之上

代理： 正向代理是指代理服务器为客户端向服务器请求资源。通俗来说，就是代理服务器代表客户端访问服务器，客户端不直接访问服务器，而是先向代理服务器发送请求，再由代理服务器向服务器请求资源。正向代理可以隐藏客户端的真实IP地址和请求信息，保护客户端隐私和访问安全

反向代理是指代理服务器为服务器端处理请求。通俗来说，就是代理服务器代表服务器向客户端提供服务，客户端不知道直接连接的是代理服务器，而是以为是连接到了服务器。反向代理可以使服务器负载均衡，提高系统性能和安全性，减少直接访问服务器的请求。

总结来说，正向代理隐藏客户端的真实信息，反向代理隐藏服务器的真实信息。正向代理代表客户端访问服务器，反向代理代表服务器向客户端提供服务

网关：接受客户端发送过来的数据，然后转发给非 `HTTP` 服务器，然后再有自己返回给客户端。因为有些服务器不是 `HTTP` 服务器，也是可以提高通信的安全性

负载均衡：客户端的请求只会先到达代理服务器，这个代理服务器拿到请求只会通过特定的算法（轮询，随机算法），发送给不同的源服务器，让各台服务器的负载尽量平均，（把访问请求均匀分散到多台机器上，实现访问集群化）

缓存代理：让代理服务器接管一部分的服务端 `HTTP` 缓存，客户端缓存过期后就近到代理缓存中获取，代理缓存过期了才请求源服务器，这样流量巨大的时候能明显降低源服务器的压力。将内容缓存代理到服务器，使得客户端可以直接从代理服务器获得而不用到源服务器那里

内容缓存： 暂存上下行的数据，减轻后端的压力

安全防护：隐藏 `IP` ，防御网络攻击，保护被代理的机器

数据处理： 提供压缩，加密等额外的功能

爬虫：各地搜索引擎放出来的，抓取网页存入庞大的数据库，再建立关键字索引，可以我们就可以快速搜索到我们想要的东西了。缺点：过度消耗网络资源，占用宽带和服务器，影响网站对真实数据的分析，敏感信息的泄漏。

## node 创建一个 http 服务器

```
let http = require("http")
let url = require('url') // 对url进行解析
// req 流对象，是可读流
// res 是一个可写流 write
// 发消息的时候不等于和客户端连接，连接是一个长连接

 let server = http.createServer((req,res)=>{

}).listen(8080,()=>{
   console.log('server starts at http://localhost:8080');
})

// 服务器监听客户端的请求，当有请求到来的时候执行回调

// req 代表客户端的连接，server 服务器把客户端的请求信息进行解析，然后放在 req 上面
// res 代表响应，如果希望向客户端响应消息，需要通过 res
server.on('request', (req, res) => {
  console.log(req.method); // 获取请求方法名
  console.log(req.url); // 获取请求路径
  console.log(req.headers); // 获取请求头对象
  let result = []

  req.on('data', data => { // 请求体
    result.push(data)
  })

  req.on('end', () => {
    let r = Buffer.concat(result)
    res.end(r) // 解析完之后返回给客户端
  })
})


server.on('close', (req, res) => {
  console.log('服务器已经关闭');
})

server.listen(8080, () => {
  console.log('server starts at http://localhost:8080');
})
```


## 参考资料

[（建议精读）HTTP 灵魂之问，巩固你的 HTTP 知识体系](https://juejin.im/post/5e76bd516fb9a07cce750746)

[终于有人把 Nginx 说清楚了，图文详解！](https://mp.weixin.qq.com/s/vZkXcMOOWu0tsZ_5a6gtew)