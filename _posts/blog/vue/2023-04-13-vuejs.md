---
layout: post
title: Vue.js 设计与实现 读后感
categories: [文章推荐]
description: vue3
keywords:  vue3
---

前几天读《Vue.js 设计与实现》，不仅get到很多基础的知识点，还惊叹于他的实现原理

## vue3 实现效率提升
编译器将模板编译为渲染函数的过程中，尽可能多地提取关键信息，并以此指导生成最优代码的过程,可能地区分动态内容和静态内容，并针对不同的内容采用不同的优化策略

### patchFlags 和 Block Tree  => 靶向更新
区分动态节点与静态节点用patchFlag，收集所有的动态子代节点用Block

patchFlag，它的值是一个数字，只要虚拟节点存在该属性，我们就认为它是一个动态节点。这里的 patchFlag 属性就是所谓的补丁标志，颗粒到最小，比如动态样式标记了，静态节点内容不会被标记

组件模板的根节点必须作为 Block 块，从根节点开始，所有动态子代节点都会被收集到根节点的 dynamicChildren 数组中。动静态节点会分别标记，更新的时候，只会对比动态节点，跳过静态节点。从而避免了没必要的diff对比
### 静态提升(属性节点)

模板会被编译为render函数（即template里面的内容），在编译的时候，如果是发现是纯静态的节点，就提升到渲染函数之外，在渲染函数内只会持有对静态节点的引用，当响应式数据变化，并使得渲染函数重新执行时，并不会重新创建静态的虚拟节点，从而避免了更新时创建虚拟 DOM 带来的性能开销和内存占用

### 预字符串化
当模板中包含大量连续纯静态的标签节点，直接编译成一个普通的字符串节点，而不是一个虚拟DOM节点，效果在ssr中特别明显

大块的静态内容可以通过 innerHTML 进行设置，在性能上具有一定优势， 同时减少创建虚拟节点产生的性能开销，减少内存占用

### 缓存内联事件处理函数
`<Comp @change="a + b" />`

每次重新渲染时（即 render 函数重新执行时），都会为 Comp 组件创建一个全新的 props 对象。同时，props 对象中 onChange 属性的值也会是全新的函数。这会导致渲染器对Comp 组件进行更新，造成额外的性能开销

```
function render(ctx) {
  return h(Comp, {
    // 内联事件处理函数
    onChange: () => (ctx.a + ctx.b)
  })
}
```

因此我们需要对内联事件处理函数进行缓存

```
function render(ctx, cache) {
  return h(Comp, {
     // 将内联事件处理函数缓存到 cache 数组中
     onChange: cache[0] || (cache[0] = ($event) => (ctx.a +ctx.b))
  })
}
```
渲染函数的第二个参数是一个数组 cache，该数组来自组件实例，我们可以把内联事件处理函数添加到 cache 数组中。这样，当渲染函数重新执行并创建新的虚拟 DOM 树时，会优先读取缓存中的事件处理函数。这样，无论执行多少次渲染函数，props 对象中 onChange 属性的值始终不变，于是就不会触发 Comp 组件更新了

### v-once指令
v-once 可实现对虚拟 DOM 的缓存，通常用于不会发生改变的动态绑定

避免组件更新时重新创建虚拟 DOM 带来的性能开销。因为虚拟 DOM 被缓存了，所以更新时无须重新创建。

避免无用的 Diff 开销。这是因为被 v-once 标记的虚拟DOM 树不会被父级 Block 节点收集

vue3 通过编译优化手段提取关键信息，并且附着到对应虚拟节点上。在运行阶段，通过关键信息执行快捷路径，从而提升性能
## 如何设计一个框架

从结果看

1. 给用户提供哪些产物？ 产物的格式是什么

2. 最终框架代码的体积

从开发看

1. 报错/警告信息如何展示给用户

2. 热更新

3. 没用用到的功能模块是否不打包到最终资源里面去

4. 用户的开发体验

## vue3 设计思路
### 如何描述UI
既可以模板来声明式的描述UI，还可以用javascript对象来描述,还支持直接使用虚拟DOM。使用 javascript 对象描述UI比模板声明更加灵活，h函数编写比javascript 对象更加轻松

javascript 对象描述

```
export default {
  render() {
    return {
      tag: 'h1',
       props: { onClick: handler }
     }
  }
}
```

用模板来描述

```
<h1 @click="handler"><span></span></h1>
```

h函数

```
 import { h } from 'vue'
 export default {
  render() {
    return h('h1', { onClick: handler }) // 虚拟 DOM
  }
 }
```

### 组件
组件就是一组 DOM 元素的封装，这组DOM元素就是组件要渲染的内容

页面都是由一个又一个组件组装而成，组件的实现依赖渲染器，模板的编译以来编译器

## 响应系统的实现原理
一个响应式数据最基本的实现依赖于对“读取”和“设置”操作的拦截，从而在副作用函数与响应式数据之间建立联系。当“读取”操作发生时，我们将当前执行的副作用函数存储到“桶”中；当“设置”操作发生时，再将副作用函数从“桶”里取出并执行。这就是响应系统的根本实现原理
### 响应式数据与副作用函数
副作用函数，这个函数执行会产生副作用的函数，比如全局变量或者影响别人使用

比如说下面这个函数
```
function modidyArr(){
  const arr = [1,2,3]
  setTimeout(()=>{
    arr.pop()
  },200)
  return arr
}
const res = modidyArr()
console.log(res,'返回的值')

setTimeout(()=>{
  console.log(res,'返回的值，和上次返回的结果不一样')
},300)
```

响应式数据，当下面的obj的text变化的时候effect能够被重新执行，这就叫响应式数据，自己变化了，所用到自己的所有函数都要重新执行

```
const obj = {text:"hello world"}
function effect(){
  document.body.innerText = obj.text
}
```

### 响应式数据的实现原理

只细观察可以发现，副作用函数effect执行的时候，会触发obj.text的读取操作，修改obj.text的时候会触发obj.text的设置操作

如果我们可以拦截这个对象的读取和设置操作，这个事情就变的简单了

当我们读取这个字段的时候，把副作用函数存到某一个桶里面，当这个对像被设置或者修改的时候，就把这个桶里面的副作用函数取出来执行

如此以来就达到了数据变化，函数重新执行。

在vue3使用的是 Proxy 进行拦截和设置

具体实现参考文章代码，或者看我本地代码，太长了

### 调度执行
响应式系统在数据变化的时候有能力决定副作用函数执行的时机次数和方式。通常是在effect函数在设计一个选项参数，允许用户指定调度器，任务队列，再后来的computed和watch等实现中都用到了

例如 computed 的粗糙实现( computed 计算属性实际上是一个懒执行的副作用函数)

```
function computed(getter){
  const effectFn = effect(getter,{lazy:true}) // 建立副作用函数,把这个getter放到那个桶里去，只要里面用的数据变化了，就会重新执行

  const obj = {
    get value(){
      return effectFn() // 读取时，才执行effectFn
    }
  }
  return obj
}
```

watch 本质就是观测响应式数据，数据变化，通知执行相对应地回调函数,利用调度执行的scheduler选项即可实现(它本质上利用了副作用函数重新执行时的可调度性)

```
function watch(source,cd){
  effect(source,{
    scheduler(){
      cd()
    }
  })
}
```

### 响应式具体实现
proxy 只能代理对象，原始类型的值我们需要用对象包装一层，进行代理。

使用 Reflect进行对象操作

set/map/array在proxy都做了单独的处理，保证在获取和设置的时候可以响应式的变化

浅响应与深响应，只读和浅读都做了处理

原始类型函数进行封装

```
  function ref(val){
    // 内部创建包装对象
    const wrapper = {
      value: val
    }
    // 区分是 ref来源的数据
    Object.defineProperty(wrapper,'__v_isRef',{value: true})
    // 包装对象变成响应式数据
    return reactive(wrapper)
  }
```

还另外实现了toRef和toRefs等对响适应数据做的一层处理

## 渲染器
渲染器就是执行渲染任务的，不仅能渲染真实的DOM元素，还能实现跨平台。以浏览器平台为例就是把虚拟 DOM 渲染为真实 DOM

我们利用响应式系统的能力，自动调用渲染器完成页面的渲染和更新。这个过程和渲染器的具体实现没有关系

我们 createRenderer 函数用来创建一个渲染器，里面包含几个函数用来实现渲染，render/hydrate(ssr)/patch/mountElement...

具体做的事情：

创建元素

为元素添加属性和事件

处理 children

更新节点，渲染器的精髓，只更新需要更新的，别的都不需要管

归根结底，都是使用一些我们熟悉的 DOM 操作 API 来完成渲染工作

在更新节点的时候，用到了diff算法，等一系列能让其更新效率的东西；

内部还有组件实现的原理，和一些内置组件是如何实现的

## 编译器
编译器就是将组件模板编译为渲染函数。其实就是对模板进行词法语法分析得到模板AST，然后将模板AST转换为Javascript AST，最后生成javascript代码的过程

讲了如何转换和状态机的内容，还有解析器如何解析处代码的一系列过程

## 总结

框架本身就是封装了命令式代码才实现了面向用户的声明式，虚拟dom的性能是否比操作原生innerHTML好，数量很小的时候会好，如果数量多了，虚拟dom会更好，因为更新的时候innnerHTML是要销毁所有的dom，然后去新建新的dom，而虚拟dom，只需要diff变化的部门，更新必要更新的地方就好了。也就是说更新操作，虚拟dom和数量级有关，innerHTML和模板大小有关系，原生Javascript的话，可维护性太差了


纯运行时的框架，由于它没有编译的过程，因此我们没办法分析用户提供的内容，但是如果加入编译步骤，可能就大不一样了，我们可以分析用户提供的内容，看看哪些内容未来可能会改变，哪些内容永远不会改变，这样我们就可以在编译的时候提取这些信息，然后将其传递给 Render 函数，Render 函数得到这些信息之后，就可以做进一步的优化了。

假如我们设计的框架是纯编译时的，那么它也可以分析用户提供的内容。由于不需要任何运行时，而是直接编译成可执行的JavaScript 代码，因此性能可能会更好，但是这种做法有损灵活性，即用户提供的内容必须编译后才能用








